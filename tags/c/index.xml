<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c on Ismail Badawi</title>
    <link>https://ismail.badawi.io/tags/c/</link>
    <description>Recent content in c on Ismail Badawi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Jun 2021 00:59:44 -0400</lastBuildDate><atom:link href="https://ismail.badawi.io/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Easy Performance Fixes Guided By Flame Graphs</title>
      <link>https://ismail.badawi.io/blog/easy-performance-fixes-guided-by-flame-graphs/</link>
      <pubDate>Tue, 08 Jun 2021 00:59:44 -0400</pubDate>
      
      <guid>https://ismail.badawi.io/blog/easy-performance-fixes-guided-by-flame-graphs/</guid>
      <description>&lt;p&gt;When I was in grad school and struggling with my Master&amp;rsquo;s thesis, I started a
small side project in order to distract myself and work on something that felt
more rewarding. This project was basically a clone of vim &amp;ndash; a terminal-based
text editor I called &lt;a href=&#34;https://github.com/isbadawi/badavi&#34;&gt;badavi&lt;/a&gt;. That was around seven years ago. I haven&amp;rsquo;t
worked on it continuously since then, but I would occasionally go back and hack
on it in short little bursts. In particular I&amp;rsquo;ve been doing this the last
couple of months, and I thought it might be interesting to write about some of
the things I&amp;rsquo;ve been up to.&lt;/p&gt;
&lt;p&gt;For this post, we&amp;rsquo;ll look at some small performance fixes I made recently,
guided by &lt;a href=&#34;https://en.wikipedia.org/wiki/Perf_(Linux)&#34;&gt;perf&lt;/a&gt; and &lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;flame graphs&lt;/a&gt;.&lt;/p&gt;</description>
      <content>&lt;p&gt;When I was in grad school and struggling with my Master&amp;rsquo;s thesis, I started a
small side project in order to distract myself and work on something that felt
more rewarding. This project was basically a clone of vim &amp;ndash; a terminal-based
text editor I called &lt;a href=&#34;https://github.com/isbadawi/badavi&#34;&gt;badavi&lt;/a&gt;. That was around seven years ago. I haven&amp;rsquo;t
worked on it continuously since then, but I would occasionally go back and hack
on it in short little bursts. In particular I&amp;rsquo;ve been doing this the last
couple of months, and I thought it might be interesting to write about some of
the things I&amp;rsquo;ve been up to.&lt;/p&gt;
&lt;p&gt;For this post, we&amp;rsquo;ll look at some small performance fixes I made recently,
guided by &lt;a href=&#34;https://en.wikipedia.org/wiki/Perf_(Linux)&#34;&gt;perf&lt;/a&gt; and &lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;flame graphs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Just for context, badavi is a small C project, something like 5000 lines
currently. It looks like this (click to expand):&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ismail.badawi.io/images/badavi.png&#34;&gt;&lt;img src=&#34;https://ismail.badawi.io/images/badavi.png&#34; alt=&#34;badavi screenshot&#34;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Some features showcased there are split windows, insert mode completion (based
on ctags), searches, and syntax highlighting.&lt;/p&gt;
&lt;p&gt;The other day I was playing around with perf and flame graphs and decided to
see if there were any low hanging fruit performance improvements that could be
made, since I had never profiled the editor before. I used &lt;code&gt;perf record -g&lt;/code&gt; to
profile a short session where I just opened a source file and jumped around the
file using various &lt;a href=&#34;https://ismail.badawi.io/blog/the-compositional-nature-of-vim/&#34;&gt;motions&lt;/a&gt;, and generated the corresponding flame graph:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ perf record -g badavi editor.c
$ perf script | FlameGraph/stackcollapse-perf.pl &amp;gt; out.perf-folded
$ FlameGraph/flamegraph.pl out.perf-folded &amp;gt; perf.svg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This was the result:&lt;/p&gt;
&lt;img src=&#34;https://ismail.badawi.io/images/flamegraphs/perf.before.svg&#34;/&gt;
&lt;p&gt;From this we can see that the majority of the time was spent inside
&lt;code&gt;editor_draw&lt;/code&gt;. As background, badavi uses a library called &lt;a href=&#34;https://github.com/tomas/termbox&#34;&gt;termbox&lt;/a&gt; to
interact with the terminal. termbox uses an array of cells as an abstraction
over the terminal grid; each cell is composed of a character, a foreground
color, and a background color. In the code, &amp;ldquo;drawing&amp;rdquo; refers to the process of
populating this array with the right characters and colors for each cell on the
screen. The array is repopulated from scratch every time we redraw the screen.&lt;/p&gt;
&lt;p&gt;Within &lt;code&gt;editor_draw&lt;/code&gt;, we see a few different code paths, but the two dominant
ones are the syntax highlighting machinery (which begins at &lt;code&gt;syntax_token_at&lt;/code&gt;)
and a call to &lt;code&gt;gb_linecol_to_pos&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Focusing in on the latter, what&amp;rsquo;s happening there is that for a given window,
we need to populate the array with the portion of the corresponding file text
that is visible on the screen. The window knows which line-and-column positions
are visible, but in order to read the corresponding characters from memory,
these positions need to be converted to offsets from the start of the file (the
file text is represented in memory as a &lt;a href=&#34;https://en.wikipedia.org/wiki/Gap_buffer&#34;&gt;gap buffer&lt;/a&gt;, which is similar to a
big array of characters that can accessed by index). This is what
&lt;code&gt;gb_linecol_to_pos&lt;/code&gt; does, and it was being called once per cell.&lt;/p&gt;
&lt;p&gt;The way this works right now is that alongside the text, the code also
maintains an array of integers storing the length of each line. Converting a
line number to an offset involves traversing this array of line lengths and
adding them up, so the operation is linear in the number of lines.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve considered changing this array from storing line lengths to storing the
offsets of each newline (or viewed another way, partial sums of the line
lengths). Then &lt;code&gt;gb_linecol_to_pos&lt;/code&gt; could be implemented in constant time, at
the cost of making edits more expensive. I might do that in the future, but in
this case, there was an easy win if just avoid calling it repeatedly like this;
instead, we can get the offset of the first visible character, and increment it
as needed for subsequent characters instead of recomputing it from scratch.
That change can be viewed here:
&lt;a href=&#34;https://github.com/isbadawi/badavi/commit/2eceda3db447832fd84b8bc6cc0b9e969e769659&#34;&gt;https://github.com/isbadawi/badavi/commit/2eceda3db447832fd84b8bc6cc0b9e969e769659&lt;/a&gt;.
With this change, the flame graph looked like this:&lt;/p&gt;
&lt;img src=&#34;https://ismail.badawi.io/images/flamegraphs/perf.after.svg&#34;/&gt;
&lt;p&gt;The time was now dominated by syntax highlighting. One of the reasons syntax
highlighting is expensive is that we end up scanning the whole file, not just
the visible part, just in case we find the start of a block comment or
multiline string (depending on the language), which would affect how the
visible characters should be colored. I had some bigger improvements in mind
for this, so I decided to just set it aside for now, and just disabled syntax
highlighting to see if anything else interesting came up. That looked like
this:&lt;/p&gt;
&lt;img src=&#34;https://ismail.badawi.io/images/flamegraphs/perf.nohighlight.svg&#34;/&gt;
&lt;p&gt;We see two other code paths that lead to &lt;code&gt;gb_linecol_to_pos&lt;/code&gt; and
&lt;code&gt;gb_pos_to_linecol&lt;/code&gt; (the reverse operation, also linear in the number of
lines). The code path on the right (&lt;code&gt;motion_apply&lt;/code&gt; -&amp;gt; &lt;code&gt;down&lt;/code&gt;) is the
implementation of the &lt;code&gt;G&lt;/code&gt; motion. As in vim, hitting &lt;code&gt;G&lt;/code&gt; in normal mode jumps
to the bottom of the file. I hadn&amp;rsquo;t noticed that it was slow, since I mostly
work with small source files, but I opened a large 25000-line source file just
to see, and found that there was indeed a very noticeable delay after hitting
&lt;code&gt;G&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The root cause of the slowness turned out to be a hack that I had put in seven
years prior, when I first implemented most of the basic motions.&lt;/p&gt;
&lt;p&gt;As in vim, motions in badavi can be prefixed with an integer count, which can
usually be understood as how many times to repeat the motion. For example,
&lt;code&gt;34j&lt;/code&gt; means to repeat &lt;code&gt;j&lt;/code&gt; 34 times, where &lt;code&gt;j&lt;/code&gt; means to move down one line.
Given this, I had written some generic code where motions were represented as
functions that returned a new position, and specifying a count caused the
function to be invoked repeatedly in a loop.&lt;/p&gt;
&lt;p&gt;But &lt;code&gt;G&lt;/code&gt; works slightly differently; &lt;code&gt;34G&lt;/code&gt; means to jump to line 34, not to
repeat &lt;code&gt;G&lt;/code&gt; 34 times. For whatever reason, I decided back then to awkwardly fit
&lt;code&gt;G&lt;/code&gt; into this &amp;ldquo;repeated motion&amp;rdquo; model by implementing it as a repeated &lt;code&gt;j&lt;/code&gt; from
the top of the file, so that for example in a file with 25000 lines, hitting
&lt;code&gt;G&lt;/code&gt; would start from the top of the file and essentially do &lt;code&gt;25000j&lt;/code&gt;. And as
the flame graph shows, the implementation of &lt;code&gt;j&lt;/code&gt; calls &lt;code&gt;gb_linecol_to_pos&lt;/code&gt; and
&lt;code&gt;gb_pos_to_linecol&lt;/code&gt;. This means &lt;code&gt;G&lt;/code&gt; was quadratic in the number of lines.&lt;/p&gt;
&lt;p&gt;I don&amp;rsquo;t really understand why I did it this way; since &lt;code&gt;G&lt;/code&gt; ends up being
special cased anyway, we might as well special case it to directly compute the
right offset. (Actually it seemed like many of the motions, such as &lt;code&gt;j&lt;/code&gt; in this
example, could be optimized if they were aware of the count instead of being
blindly called repeatedly, but I decided to leave that for later). The change
can be viewed here:
&lt;a href=&#34;https://github.com/isbadawi/badavi/commit/3f64704a9dd4c768880f71f7693e7240c44c7529&#34;&gt;https://github.com/isbadawi/badavi/commit/3f64704a9dd4c768880f71f7693e7240c44c7529&lt;/a&gt;.
Here is the corresponding flame graph:&lt;/p&gt;
&lt;img src=&#34;https://ismail.badawi.io/images/flamegraphs/perf.fixedg.svg&#34;/&gt;
&lt;p&gt;The other code path leading to &lt;code&gt;gb_pos_to_linecol&lt;/code&gt; was the code that displays
the line number for each line. badavi supports relative line numbers, similar
to vim, where rather than displaying the actual line numbers, we display the
line numbers relative to the line number of the cursor (this can be seen in the
screenshot above). In the code, windows keep track of their cursor position as
an offset, so it needs to be converted to a line number, and
&lt;code&gt;window_draw_line_number&lt;/code&gt; just happened to repeatedly recompute it instead of
doing it once and reusing it. That fix can be viewed here:
&lt;a href=&#34;https://github.com/isbadawi/badavi/commit/13bb413011c9d3cb1732961a3dd069d45aa87105&#34;&gt;https://github.com/isbadawi/badavi/commit/13bb413011c9d3cb1732961a3dd069d45aa87105&lt;/a&gt;.
And the corresponding flame graph:&lt;/p&gt;
&lt;img src=&#34;https://ismail.badawi.io/images/flamegraphs/perf.fixedline.svg&#34;/&gt;
&lt;p&gt;There&amp;rsquo;s not as much an obvious bottleneck here, and we see a broad mix of code
paths being represented, including the dynamic linking that happens at process
spawn time, the loading of the source file, and the ctags file, so this seemed
like a good place to stop for now.&lt;/p&gt;
&lt;p&gt;I found this process to be pretty rewarding. In general, profiling an
application and looking at flame graphs can often quickly lead to a lot of
&amp;ldquo;obvious&amp;rdquo; insights that may not have been so obvious just from reading the code
(especially if this is the first time profiling this application). Not all
issues are as simple to track down and fix as the ones described in this post,
but I think it is often the case that many problems become easy if you can just
see what a program is actually doing.&lt;/p&gt;</content>
    </item>
    
    <item>
      <title>A Bug Caused by Using 0 Instead of Null</title>
      <link>https://ismail.badawi.io/blog/a-bug-caused-by-using-0-instead-of-null/</link>
      <pubDate>Tue, 08 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ismail.badawi.io/blog/a-bug-caused-by-using-0-instead-of-null/</guid>
      <description>&lt;p&gt;This is a quick post about a bug I ran into at work which turned out to be
caused by passing a literal &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;NULL&lt;/code&gt; to a function. Here&amp;rsquo;s a
small program reproducing it:&lt;/p&gt;</description>
      <content>&lt;p&gt;This is a quick post about a bug I ran into at work which turned out to be
caused by passing a literal &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;NULL&lt;/code&gt; to a function. Here&amp;rsquo;s a
small program reproducing it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdarg.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; arg, ...) {
  va_list args;
  va_start(args, arg);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; arg; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
    p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; va_arg(args, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;);
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (p) {
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;p was non-null: %p&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, p);
  } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;p was null&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
  }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  f(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
  f(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Compiling this as a 64-bit program on an x86-64 processor with clang
and running it gives this output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ clang test.c
$ ./a.out
p was null
p was non-null: 0x7fff00000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What is going on here?&lt;/p&gt;
&lt;p&gt;First, what is this &lt;code&gt;f&lt;/code&gt; function doing? It takes an integer argument,
followed by a variable number of arguments. It uses the first argument
to decide which of the variable arguments to look at (starting at 1),
and interprets it as a pointer value. Thus, if the call looked like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;f(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then &lt;code&gt;p&lt;/code&gt; would take on the value &lt;code&gt;(int*)3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For the two calls in the program, I&amp;rsquo;m passing in 6 literal &lt;code&gt;0&lt;/code&gt;s as the variable
arguments. The first call examines the 5th one, and the second the 6th one. In
the first case, &lt;code&gt;p&lt;/code&gt; turns out be 0, as expected. But in the second case, it is
nonzero. How come?&lt;/p&gt;
&lt;p&gt;There are two things going on.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In the &lt;a href=&#34;http://www.x86-64.org/documentation/abi.pdf&#34;&gt;x86-64 calling convention&lt;/a&gt; (refer to section 3.2.3), up to six
integer arguments can be passed in registers. In the case of &lt;code&gt;f&lt;/code&gt;, this
includes the fixed positional argument &lt;code&gt;arg&lt;/code&gt;, and then up to 5 arguments. In
both calls I am passing six extra arguments, so the last one is passed on
the stack, instead of in a register.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In C, the literal &lt;code&gt;0&lt;/code&gt; has type &lt;code&gt;int&lt;/code&gt;, which is a 32-bit value. Thus, 32 bits
worth of zeros are placed on the stack at the call site. But when &lt;code&gt;f&lt;/code&gt;
interprets the argument as a pointer, it reads 64 bits from the stack. The
first 32 bits are zeros, but the next 32 are garbage &amp;ndash; whatever happens to
be on the stack (which could happen to be all zeros, or it might not, as in
this case).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If the last argument was &lt;code&gt;NULL&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;, then 64 bits worth of zeros
would have been placed on the stack at the call site, since &lt;code&gt;NULL&lt;/code&gt; is typically
defined as something like &lt;code&gt;((void*)0)&lt;/code&gt;, which is an expression of pointer type.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m not sure how consistent this behavior is across platforms or compilers. In
particular, it seems that there exist ABIs where values passed as varargs are
automatically sign-extended to 64 bits &amp;ndash; so the program here would be fine.&lt;/p&gt;
&lt;p&gt;I tend to avoid using varargs in C, unless I&amp;rsquo;m just wrapping &lt;code&gt;printf&lt;/code&gt; or
something. They&amp;rsquo;re not type-checked, which is already giving up a lot, and then
on 64-bit systems they can be pretty complicated to reason about. Here is an
&lt;a href=&#34;https://blog.nelhage.com/2010/10/amd64-and-va_arg/&#34;&gt;interesting article&lt;/a&gt; about the implementation of varargs in the amd64
ABI.&lt;/p&gt;</content>
    </item>
    
    <item>
      <title>When Optimizations Hide Bugs</title>
      <link>https://ismail.badawi.io/blog/when-optimizations-hide-bugs/</link>
      <pubDate>Mon, 07 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ismail.badawi.io/blog/when-optimizations-hide-bugs/</guid>
      <description>&lt;p&gt;The past few months at work I&amp;rsquo;ve been working with a large legacy codebase,
mostly written in C. In order to debug problems as they come up, I wanted to
use gdb &amp;ndash; but it seemed like the program was only ever compiled with
optimizations turned on (&lt;code&gt;-O2&lt;/code&gt;), which can make using gdb a frustrating
experience, as every interesting value you might want to examine has been
optimized out.&lt;/p&gt;
&lt;p&gt;After grappling with the build system to pass &lt;code&gt;-O0&lt;/code&gt; in all the right places (a
surprisingly difficult task), I found that the program did not link with
optimizations turned off. Once I got around that, I ran into a crash in some
basic functionality, easily reproducible at &lt;code&gt;-O0&lt;/code&gt;, but not &lt;code&gt;-O2&lt;/code&gt;. This post
contains two tiny contrived programs reproducing those issues.&lt;/p&gt;</description>
      <content>&lt;p&gt;The past few months at work I&amp;rsquo;ve been working with a large legacy codebase,
mostly written in C. In order to debug problems as they come up, I wanted to
use gdb &amp;ndash; but it seemed like the program was only ever compiled with
optimizations turned on (&lt;code&gt;-O2&lt;/code&gt;), which can make using gdb a frustrating
experience, as every interesting value you might want to examine has been
optimized out.&lt;/p&gt;
&lt;p&gt;After grappling with the build system to pass &lt;code&gt;-O0&lt;/code&gt; in all the right places (a
surprisingly difficult task), I found that the program did not link with
optimizations turned off. Once I got around that, I ran into a crash in some
basic functionality, easily reproducible at &lt;code&gt;-O0&lt;/code&gt;, but not &lt;code&gt;-O2&lt;/code&gt;. This post
contains two tiny contrived programs reproducing those issues.&lt;/p&gt;
&lt;h2 id=&#34;optimizing-away-a-reference-to-an-undefined-variable&#34;&gt;Optimizing away a reference to an undefined variable&lt;/h2&gt;
&lt;p&gt;As I mentioned, although the program compiled at &lt;code&gt;-O0&lt;/code&gt;, it did not link. Here&amp;rsquo;s
a small program that reproduces this. This program is totally contrived, but it
should hopefully not be too difficult to imagine seeing something like this in
real code.&lt;/p&gt;
&lt;p&gt;There are three files involved here.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#pragma once
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; foo_global;

&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;use_foo_global&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; foo_global;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;foo.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; foo_global &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;foo.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ok_to_use_foo&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ok_to_use_foo()) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; use_foo_global();
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;main.c&lt;/code&gt; includes &lt;code&gt;foo.h&lt;/code&gt;, which contains a &lt;code&gt;static inline&lt;/code&gt; function which
references a global variable which is defined in &lt;code&gt;foo.c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s the thing, though &amp;ndash; although &lt;code&gt;main.c&lt;/code&gt; includes &lt;code&gt;foo.h&lt;/code&gt;, it is actually
not linked with &lt;code&gt;foo.c&lt;/code&gt;. It is built on its own. (In the real code, this
&lt;code&gt;foo.c&lt;/code&gt; was sometimes included in the build and sometimes not, depending on
which variant of the program you were building.)&lt;/p&gt;
&lt;p&gt;When I compile this with clang without optimizations, I predictably get this
undefined reference error:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ clang main.c
Undefined symbols &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; architecture x86_64:
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;_foo_global&amp;#34;&lt;/span&gt;, referenced from:
      _use_foo_global in test-11ddda.o
ld: symbol&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; not found &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; architecture x86_64
clang-3.6: error: linker command failed with exit code &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;use -v to see invocation&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The program references &lt;code&gt;foo_global&lt;/code&gt;, but &lt;code&gt;foo_global&lt;/code&gt; is defined in &lt;code&gt;foo.c&lt;/code&gt;
which is not linked into the program.&lt;/p&gt;
&lt;p&gt;Of course, if you look closely, you&amp;rsquo;ll see that the program actually never ends
up using &lt;code&gt;foo_global&lt;/code&gt; at runtime, based on some simple logic which is
actually constant, but since it includes a function call, clang won&amp;rsquo;t figure
out at &lt;code&gt;-O0&lt;/code&gt; that it is constant. (In the real code, this &lt;code&gt;ok_to_use_foo&lt;/code&gt;
function contained logic involving a few different preprocessor variables, but
it was still ultimately constant).&lt;/p&gt;
&lt;p&gt;At &lt;code&gt;-O2&lt;/code&gt;, clang will easily figure out that the conditional is always false, so
it will optimize away the branch, which included the only call to that inline
function, so the function will be optimized away entirely also, taking with it
the reference to &lt;code&gt;foo_global&lt;/code&gt;. Thus the program compiles cleanly and does what
you&amp;rsquo;d expect:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ clang -O2 main.c
$ ./a.out
$ echo $?
&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;optimizing-away-a-corrupted-stack-variable&#34;&gt;Optimizing away a corrupted stack variable&lt;/h2&gt;
&lt;p&gt;Consider this small program:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obtain_two_pointers&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;a, &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;b) {
  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a;
  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;c;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a;

  c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b;
  printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%c: %p&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, c);
  obtain_two_pointers(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b);
  printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%c: %p&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, c);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this contrived program, &lt;code&gt;obtain_two_pointers&lt;/code&gt; returns two pointers via
output parameters. The calling code only cares about the first, so it passes in
the address of a dummy local variable &lt;code&gt;b&lt;/code&gt; to hold the second one.&lt;/p&gt;
&lt;p&gt;When I compile this program with clang without optimizations and run it, I get this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ clang foo.c
foo.c:14:24: warning: incompatible pointer types passing &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;int *&amp;#39;&lt;/span&gt; to parameter of type &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;void **&amp;#39;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-Wincompatible-pointer-types&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
  obtain_two_pointers&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&amp;amp;a, &amp;amp;b&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;;
                       ^~
foo.c:3:47: note: passing argument to parameter &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt; here
static void obtain_two_pointers&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;void **a, void **b&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                                              ^
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; warning generated.
$ ./a.out
c: 0x7fff5118947c
c: 0x7fff00007fff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The problem is that the code was written assuming that pointers were 32 bits
wide, so that you could fit a pointer inside an &lt;code&gt;int&lt;/code&gt; variable. On my machine,
however, pointers are 64 bits wide, so that when &lt;code&gt;obtain_two_pointers&lt;/code&gt; writes
64 bits into the address of &lt;code&gt;b&lt;/code&gt;, it corrupts the value of &lt;code&gt;c&lt;/code&gt;, which is next to
it on &lt;code&gt;main&lt;/code&gt;&amp;rsquo;s stack. This explains the output: after calling the function, the
lower 32 bits of &lt;code&gt;c&lt;/code&gt; are overwritten with the beginning of a pointer value. If
we were to dereference &lt;code&gt;c&lt;/code&gt; at this point, the program might crash.&lt;/p&gt;
&lt;p&gt;Incidentally, the warning clang gives here is totally on-point, but this being
a huge legacy codebase, clang actually generates thousands of warnings, so this
one went unnoticed. While there are efforts underway to go through and address
all the warnings, it will probably take years before the program compiles
cleanly.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s compile and run this program with optimizations turned on:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ clang -w -O2 foo.c
$ ./a.out
c: 0x7fff5c9f9470
c: 0x7fff5c9f9470
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What happens here is that &lt;code&gt;c&lt;/code&gt; gets optimized out, and the address of &lt;code&gt;b&lt;/code&gt; is
passed to the two &lt;code&gt;printf&lt;/code&gt; invocations directly. There is still an extra 32
bits written onto the stack, but they&amp;rsquo;re harmless. (Actually in this case the
call to &lt;code&gt;obtain_two_pointers&lt;/code&gt; gets inlined so it&amp;rsquo;s not quite that simple. If
the function is declared &lt;code&gt;extern&lt;/code&gt; and defined in another file, like it was in
the real code, then it&amp;rsquo;s easy to see that &lt;code&gt;c&lt;/code&gt; is just optimized out.)&lt;/p&gt;
&lt;h2 id=&#34;lessons-learned&#34;&gt;Lessons learned&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Optimizations are behavior preserving, but not undefined behavior preserving.
In the second program, the implicit cast from &lt;code&gt;int*&lt;/code&gt; to &lt;code&gt;void**&lt;/code&gt; when &lt;code&gt;&amp;amp;b&lt;/code&gt; is
passed to the function is undefined behavior. That&amp;rsquo;s why optimizing out &lt;code&gt;c&lt;/code&gt;
is a valid transformation even though it changes the behavior of the program.
(I think.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Being conscientious about compiler warnings can pay off. I&amp;rsquo;ve encountered
people who say that compiler warnings are more trouble than they&amp;rsquo;re worth,
because the issues they find are either false positives, or trivial bugs that
anyone would see. It is true that the bug in the second program is not hard
to see &amp;ndash; if anyone had had cause to read through that part of the code, they
would have likely spotted it immediately. Unfortunately, in very large
codebases, a lot of code is left to rot, only examined if it appears in the
stack trace of a core file after a crash; at least, that&amp;rsquo;s how I found this
bug. But the compiler always reads all of the code, so if nothing else it can
help find these trivial bugs in rarely-read code.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
    </item>
    
  </channel>
</rss>
